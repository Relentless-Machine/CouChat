-- Database schema for CouChat
-- Version: 1.1
-- Last Updated: 2025-06-13

-- Stores individual messages
CREATE TABLE IF NOT EXISTS messages (
    message_id TEXT PRIMARY KEY,          -- UUID, generated by the application
    conversation_id TEXT NOT NULL,        -- FK to conversations table, groups messages
    sender_id TEXT NOT NULL,              -- ID of the sender (user_id)
    recipient_id TEXT,                    -- ID of the recipient (user_id), can be NULL for group messages initially or if not applicable
    payload TEXT NOT NULL,                -- Encrypted message content (JSON)
    message_type TEXT NOT NULL,           -- Type of message (e.g., TEXT, FILE_INFO, READ_RECEIPT)
    original_message_id TEXT,             -- For replies, references messages.message_id
    status TEXT DEFAULT 'PENDING',        -- PENDING, SENT, DELIVERED, READ, FAILED
    read_at DATETIME DEFAULT NULL,        -- Timestamp when the message was read by recipient
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (conversation_id) REFERENCES conversations(conversation_id) ON DELETE CASCADE, -- Added ON DELETE CASCADE
    FOREIGN KEY (original_message_id) REFERENCES messages(message_id) ON DELETE SET NULL, -- Assuming original_message_id can be nulled if original is deleted
    FOREIGN KEY (sender_id) REFERENCES users(user_id) ON DELETE CASCADE, -- If user is deleted, their messages are deleted
    FOREIGN KEY (recipient_id) REFERENCES users(user_id) ON DELETE SET NULL -- Allow NULL if recipient is a group or not yet defined
);

-- Stores user information
CREATE TABLE IF NOT EXISTS users (
    user_id TEXT PRIMARY KEY,             -- UUID, generated by the application
    username TEXT UNIQUE NOT NULL,        -- User's chosen display name
    password_hash TEXT,                   -- Hash of the user's password (if local auth is used)
    public_key TEXT,                      -- User's main RSA public key (string format)
    oauth_provider TEXT,                  -- OAuth provider (e.g., GOOGLE, MICROSOFT)
    oauth_id TEXT,                        -- User's unique ID from the OAuth provider
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_seen_at DATETIME,                -- Last time the user was active
    UNIQUE (oauth_provider, oauth_id)
);

-- Stores group chat information
CREATE TABLE IF NOT EXISTS groups (
    group_id TEXT PRIMARY KEY,            -- UUID, generated by the application
    group_name TEXT NOT NULL,
    created_by TEXT NOT NULL,             -- user_id of the creator
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP, -- For group name changes etc.
    FOREIGN KEY (created_by) REFERENCES users(user_id)
);

-- Maps users to groups they are members of
CREATE TABLE IF NOT EXISTS group_members (
    group_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    role TEXT DEFAULT 'MEMBER',           -- e.g., MEMBER, ADMIN
    joined_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (group_id, user_id),
    FOREIGN KEY (group_id) REFERENCES groups(group_id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

-- Stores device-specific information, including passkeys
CREATE TABLE IF NOT EXISTS devices (
    device_id TEXT PRIMARY KEY,           -- Unique identifier for the device (e.g., hardware ID or UUID)
    user_id TEXT NOT NULL,
    device_name TEXT,                     -- User-friendly name for the device (e.g., "My Laptop")
    passkey_credential_id TEXT UNIQUE,    -- The credential ID for WebAuthn/Passkey
    passkey_public_key TEXT,              -- The public key part of the passkey credential
    passkey_sign_count INTEGER,           -- Signature counter for the passkey
    device_public_key TEXT,               -- Device-specific RSA public key (if different from passkey)
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_active_at DATETIME,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);

-- Tracks file transfer details
CREATE TABLE IF NOT EXISTS file_transfers (
    file_id TEXT PRIMARY KEY,             -- UUID, generated by the application
    message_id TEXT NOT NULL UNIQUE,      -- Links to the FILE_INFO message in messages table
    file_name TEXT NOT NULL,
    file_size BIGINT NOT NULL,
    mime_type TEXT,
    local_path TEXT,                      -- Path where the file is stored/downloaded locally
    status TEXT DEFAULT 'PENDING',        -- PENDING, ACCEPTED, IN_PROGRESS, COMPLETED, FAILED, REJECTED, CANCELLED
    hash_value TEXT,                      -- Hash of the file for integrity checks (e.g., SHA-256)
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (message_id) REFERENCES messages(message_id)
);

-- Manages conversations for easy listing and UI updates
CREATE TABLE IF NOT EXISTS conversations (
    conversation_id TEXT PRIMARY KEY,     -- UUID, or a composite ID like 'user_:<user_id>' or 'group_:<group_id>'
                                          -- For simplicity, application-generated UUID is fine.
    target_peer_id TEXT NOT NULL,         -- If individual chat, other user_id. If group chat, group_id.
    conversation_type TEXT NOT NULL,      -- 'INDIVIDUAL' or 'GROUP'
    last_message_id TEXT,                 -- FK to messages.message_id
    last_message_timestamp DATETIME,      -- Denormalized for sorting
    unread_count INTEGER DEFAULT 0,
    is_archived BOOLEAN DEFAULT 0,
    is_muted BOOLEAN DEFAULT 0,
    is_pinned BOOLEAN DEFAULT 0,          -- For pinning conversations to the top
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP, -- When the conversation was initiated
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP, -- Timestamp of the last activity (new message, read, etc.)
    FOREIGN KEY (last_message_id) REFERENCES messages(message_id) ON DELETE SET NULL
    -- Note: target_peer_id could reference users(user_id) or groups(group_id)
    -- but SQLite doesn't enforce polymorphic associations directly with FOREIGN KEY.
    -- This link will be maintained by application logic.
);

-- Indexes for performance
-- Note: CREATE INDEX IF NOT EXISTS is also good practice
DROP INDEX IF EXISTS idx_messages_conversation_id;
DROP INDEX IF EXISTS idx_messages_timestamp;
DROP INDEX IF EXISTS idx_messages_status;
DROP INDEX IF EXISTS idx_messages_sender_id;
DROP INDEX IF EXISTS idx_messages_recipient_id; -- Added for recipient_id

DROP INDEX IF EXISTS idx_users_username;

DROP INDEX IF EXISTS idx_group_members_user_id;
DROP INDEX IF EXISTS idx_group_members_group_id;

DROP INDEX IF EXISTS idx_devices_user_id;
DROP INDEX IF EXISTS idx_devices_passkey_credential_id;

DROP INDEX IF EXISTS idx_file_transfers_message_id;
DROP INDEX IF EXISTS idx_file_transfers_status;

DROP INDEX IF EXISTS idx_conversations_target_peer_id;
DROP INDEX IF EXISTS idx_conversations_type;
DROP INDEX IF EXISTS idx_conversations_updated_at;
DROP INDEX IF EXISTS idx_conversations_is_pinned;

CREATE INDEX IF NOT EXISTS idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(timestamp);
CREATE INDEX IF NOT EXISTS idx_messages_status ON messages(status);
CREATE INDEX IF NOT EXISTS idx_messages_sender_id ON messages(sender_id);
CREATE INDEX IF NOT EXISTS idx_messages_recipient_id ON messages(recipient_id); -- Added for recipient_id

CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);

CREATE INDEX IF NOT EXISTS idx_group_members_user_id ON group_members(user_id);
CREATE INDEX IF NOT EXISTS idx_group_members_group_id ON group_members(group_id);

CREATE INDEX IF NOT EXISTS idx_devices_user_id ON devices(user_id);
CREATE INDEX IF NOT EXISTS idx_devices_passkey_credential_id ON devices(passkey_credential_id);

CREATE INDEX IF NOT EXISTS idx_file_transfers_message_id ON file_transfers(message_id);
CREATE INDEX IF NOT EXISTS idx_file_transfers_status ON file_transfers(status);

CREATE INDEX IF NOT EXISTS idx_conversations_target_peer_id ON conversations(target_peer_id);
CREATE INDEX IF NOT EXISTS idx_conversations_type ON conversations(conversation_type);
CREATE INDEX IF NOT EXISTS idx_conversations_updated_at ON conversations(updated_at);
CREATE INDEX IF NOT EXISTS idx_conversations_is_pinned ON conversations(is_pinned);
