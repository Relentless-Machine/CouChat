// src/services/MessageService.ts

// const API_BASE_URL = 'http://localhost:8121/api/messages'; // Defined in config or used directly
import { API_BASE_URL_MESSAGES } from '../config'; // Assuming API_BASE_URL_MESSAGES = 'http://localhost:8121/api/messages'

// Define MessageType and MessageStatus enums to match backend
export enum MessageType {
  TEXT = 'TEXT',
  FILE_INFO = 'FILE_INFO',
  SYSTEM = 'SYSTEM',
  READ_RECEIPT = 'READ_RECEIPT',
}

export enum MessageStatus {
  PENDING = 'PENDING',
  SENT = 'SENT',
  DELIVERED = 'DELIVERED',
  READ = 'READ',
  FAILED = 'FAILED',
}

// Define the Message interface matching backend com.couchat.messaging.model.Message
export interface Message {
  id: string; // UUID string, generated by backend
  conversationId: string;
  senderId: string;
  recipientId: string;
  type: MessageType;
  payload: string; // For TEXT, this is the message text. For FILE_INFO, this could be JSON string of file metadata.
  timestamp: string | Date; // ISO string from backend, converted to Date object in frontend
  status: MessageStatus;
  originalMessageId?: string | null; // For replies
}

// Error type for API responses
interface ApiError {
  message: string;
  details?: any;
}

// DTO for sending a new message
export interface SendMessageDTO {
  conversationId: string; // Crucial: Client must determine/provide this.
  recipientId: string;
  type: MessageType;
  payload: string;
  originalMessageId?: string | null;
}

/**
 * Sends a new message to the backend.
 * @param messageDto The message data transfer object.
 * @returns A Promise that resolves to the saved Message object from the backend.
 */
export const sendMessage = async (messageDto: SendMessageDTO): Promise<Message> => {
  try {
    const response = await fetch(`${API_BASE_URL_MESSAGES}`, { // POST to /api/messages
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        // Add Authorization header if needed, e.g., from AuthContext
      },
      body: JSON.stringify(messageDto),
    });

    if (!response.ok) {
      const errorData: ApiError = await response.json().catch(() => ({ message: `Failed to send message: ${response.statusText}` }));
      console.error('MessageService: Send message API error:', errorData);
      throw new Error(`Send message failed: ${errorData.message || response.statusText}`);
    }

    const savedMessage: Message = await response.json();
    return savedMessage;
  } catch (error) {
    console.error('MessageService: Error calling send message API:', error);
    if (error instanceof Error) {
      throw error;
    }
    throw new Error('An unexpected error occurred while sending the message.');
  }
};

/**
 * Fetches messages for a specific conversation from the backend.
 * @param conversationId The ID of the conversation.
 * @param limit Optional limit for pagination.
 * @param offset Optional offset for pagination.
 * @returns A Promise that resolves to an array of Message objects.
 */
export const getMessagesByConversationIdAPI = async (
  conversationId: string,
  limit: number = 50, // Default limit
  offset: number = 0    // Default offset
): Promise<Message[]> => {
  try {
    const response = await fetch(`${API_BASE_URL_MESSAGES}/conversation/${conversationId}?limit=${limit}&offset=${offset}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        // Add Authorization header if needed
      },
    });

    if (!response.ok) {
      const errorData: ApiError = await response.json().catch(() => ({ message: `Failed to fetch messages: ${response.statusText}` }));
      console.error('MessageService: Get messages API error:', errorData);
      throw new Error(`Failed to fetch messages: ${errorData.message || response.statusText}`);
    }

    const messages: Message[] = await response.json();
    // Ensure timestamps are Date objects if needed by frontend, though ChatPage handles this conversion currently
    return messages.map(msg => ({ ...msg, timestamp: new Date(msg.timestamp) }));
  } catch (error) {
    console.error('MessageService: Error calling get messages API:', error);
    if (error instanceof Error) {
      throw error;
    }
    throw new Error('An unexpected error occurred while fetching messages.');
  }
};

/**
 * Marks all messages in a conversation as read for the current user.
 * @param conversationId The ID of the conversation.
 * @returns A Promise that resolves when the operation is successful.
 */
export const markConversationAsReadAPI = async (conversationId: string): Promise<void> => {
  try {
    const response = await fetch(`${API_BASE_URL_MESSAGES}/conversation/${conversationId}/read`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        // Add Authorization header if needed
      },
    });

    if (!response.ok) {
      const errorData: ApiError = await response.json().catch(() => ({ message: `Failed to mark as read: ${response.statusText}` }));
      console.error('MessageService: Mark as read API error:', errorData);
      throw new Error(`Failed to mark conversation as read: ${errorData.message || response.statusText}`);
    }
    // No content expected on successful POST for this endpoint usually
  } catch (error) {
    console.error('MessageService: Error calling mark as read API:', error);
    if (error instanceof Error) {
      throw error;
    }
    throw new Error('An unexpected error occurred while marking conversation as read.');
  }
};

// Removed encryptMessageAPI and decryptMessageAPI as per plan
